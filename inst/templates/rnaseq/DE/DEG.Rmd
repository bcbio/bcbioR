---
title: "Differential Expression"
author: "Harvard Chan Bioinformatics Core"
date: "`r Sys.Date()`"
output:
   html_document:
      code_folding: hide
      df_print: paged
      highlights: pygments
      number_sections: true
      self_contained: true
      theme: default
      toc: true
      toc_float:
         collapsed: true
         smooth_scroll: true
editor_options: 
  chunk_output_type: inline
params:
    ## Combatseq and ruv can both be false or ONLY ONE can be true
  # numerator: tumor
  # denominator: normal
  column: "sample_type"
  contrasts: !r list(c("sample_type", "tumor", "normal"))
  subset_column: null
  subset_value: null
  genome: hg38
  ruv: true
  combatseq: false
  params_file: params_de-example.R
  project_file: ../information.R
  functions_file: ../libs
---

Template developed with materials from https://hbctraining.github.io/main/.

```{r}
# This set up the working directory to this file so all files can be found
library(rstudioapi)
setwd(fs::path_dir(getSourceEditorContext()$path))
# NOTE: This code will check version, this is our recommendation, it may work
#.      other versions
stopifnot(R.version$major>= 4) # requires R4
stopifnot(compareVersion(R.version$minor,"3.3")==0) # requires >=4.3.3
stopifnot(compareVersion(BiocManager::version(), "3.18")>=0)
```

This code is in this ![](https://img.shields.io/badge/status-stable-green) revision.

```{r load_params, cache = FALSE, message = FALSE, warning=FALSE}
library(tidyverse)
# 1. Set up input files in this R file (params_de.R)
source(params$params_file)
# 2. Set up project file (already done from QC probably)
source(params$project_file)
# 3. Load custom functions to load data from coldata/metrics/counts
map(list.files(params$functions_file,pattern = "*.R$",full.names = T),source) %>% invisible()
# IMPORTANT set these values if you are not using the parameters in the header (lines 22-31)
genome=params$genome
column=params$column
contrasts=params$contrasts
# numerator=params$numerator
# denominator=params$denominator
subset_column=params$subset_column
subset_value=params$subset_value
run_ruv=params$ruv
run_combatseq=params$combatseq
run_rmv=run_ruv | run_combatseq
factor_of_interest <- column
```


```{r load_libraries, cache = FALSE, message = FALSE, warning=FALSE}
library(rtracklayer)
library(DESeq2)
library(tidyverse)
library(stringr)
library(DEGreport)
library(ggpubr)
library(msigdbr)
library(fgsea)
library(org.Hs.eg.db)
library(knitr)
library(EnhancedVolcano)
library(bcbioR)
library(ggprism)
library(viridis)
library(pheatmap)
library(janitor)
library(ggforce)
library(vegan)
library(htmltools)

colors=cb_friendly_cols(1:15)
ggplot2::theme_set(theme_prism(base_size = 14))
opts_chunk[["set"]](
    cache = F,
    cache.lazy = FALSE,
    dev = c("png", "pdf"),
    error = TRUE,
    highlight = TRUE,
    message = FALSE,
    prompt = FALSE,
    tidy = FALSE,
    warning = FALSE,
    echo = T, 
    fig.height = 4)

# set seed for reproducibility
set.seed(1234567890L)
```

```{r sanitize_datatable}
sanitize_datatable = function(df, ...) {
 # remove dashes which cause wrapping
 DT::datatable(df, ..., rownames=gsub("-", "_", rownames(df)),
                   colnames=gsub("-", "_", colnames(df)))
}
```

```{r load_data, message=F, warning=F}
# This code will load from bcbio or nf-core folder
# NOTE make sure to set numerator and denominator
coldata <- load_coldata(coldata_fn, column,
                        subset_column, subset_value)
coldata$sample=row.names(coldata)

counts <- load_counts(counts_fn)
counts <- counts[,colnames(counts) %in% coldata$sample]

metrics <- load_metrics(se_object, multiqc_data_dir, gtf_fn, counts) %>% 
  left_join(coldata, by = c('sample')) %>% 
  as.data.frame()
rownames(metrics) <- metrics$sample
# if the names don't match in order or string check files names and coldata information
counts = counts[,rownames(metrics)]
coldata = coldata[rownames(metrics),]
coldata[[contrasts[[1]][1]]] = relevel(as.factor(coldata[[contrasts[[1]][1]]]), contrasts[[1]][3])
stopifnot(all(names(counts) == rownames(metrics)))
```

# Overview

-   Project: `r project`
-   PI: `r PI`
-   Analyst: `r analyst`
-   Experiment: `r experiment`
-   Aim: `r aim`

```{r load_counts_data}

rdata = AnnotationDbi::select(org.Hs.eg.db, rownames(counts), 'SYMBOL', 'ENSEMBL') %>%
  dplyr::select(gene_id = ENSEMBL, gene_name = SYMBOL) %>% 
  distinct(gene_id, .keep_all = TRUE)

```

# Set up

We recommend not to filter before DESeq2 since it will be handling by it. There are cases where pre-filtering could be good:

- large number of drop-outs, to reduce computation
- large number of samples, to reduce computation
- unbalanced groups, many less samples for one group than another, maybe filtering by group is an option.


```{r setup_RUV}
dds_to_use <- DESeqDataSetFromMatrix(counts, coldata, design = ~1)

vsd_before <- vst(dds_to_use)
norm_matrix = assay(vsd_before)
```


# PCA and group level variance.

**Principal Component Analysis (PCA) is a statistical technique used to simplify high-dimensional data by identifying patterns and reducing the number of variables. In the context of gene expression, PCA helps analyze large datasets containing information about the expression levels of thousands of genes across different samples (e.g., tissues, cells).**

Dispersion estimates are a key part of the DESEQ2 analysis. DESEQ2 uses data from all samples and all genes to generate a relationship between level expression and variance and then shrinks per gene dispersions to match this distribution. If one group has higher variance than all others this will affect the dispersion estimates. Here we visually check that the variance per group is similar using a PCA. The ellipses are minimal volume enclosing ellipses using the Khachiyan algorithm.

**It is best practice NOT to subset your data unless one group has significantly higher variance than the others. The best dispersion estimates are obtained with more data.**

**This code automatically uses the column value from the header. You can also manually add a factor of interest to define the groups. One can be created by combining multiple metadata columns using the paste0 function.**

```{r set group, eval=FALSE, echo=FALSE}
## Example of creating a group covariate

meta$group <- paste0(meta$sex,"_", meta$age,"_",meta$treatment)

factor_of_interest <- "insert column name for covariate of interest"
```


```{r PCA}
pca <- degPCA(norm_matrix, metrics,
              condition = factor_of_interest, name = "sample", data = T)

pca$plot + ggtitle(paste0("All samples", "\nPCA using ", nrow(vsd_before), " genes")) +
  theme(plot.title=element_text(hjust=0.5)) +
  geom_mark_ellipse(aes(color = sample_type)) +  scale_color_cb_friendly()
```

## Analysis of the variance by group

Groups in a univariate analysis can also differ with regard to their mean values, variation around those means, or both. In univariate analyses, dispersion can be examined using Levene’s test.  PERMDISP is a multivariate extension of Levene’s test to examine whether groups differ in variability. In essence, PERMDISP involves calculating the distance from each data point to its group centroid and then testing whether those distances differ among the groups. [Source](https://uw.pressbooks.pub/appliedmultivariatestatistics/chapter/permdisp/)

Here we apply this test to our variance stabilized data. We calculate distances between samples and then use the `betadisper()` function from the popular vegan package. We get two overall p-values where significant means that the dispersions are different between groups. The first p-value comes from the `anova()` function and the second from the `permutest()` function. We also get pairwise p-values for every group-group comparison.

```{r PERMDISP}
vare.disa <- vegdist(t(assay(vsd_before)))

mod = betadisper(vare.disa, metrics[[factor_of_interest]])
anova(mod)
permutest(mod, pairwise = TRUE)

```


# Covariate analysis

Multiple factors related to the experimental design or quality of sequencing may influence the outcomes of a given RNA-seq experiment. To further determine whether any confounding covariate risks affecting the results of our differential expression analyses, it is useful to assess the correlation between covariates and principal component (PC) values.

Here, we are using `DEGreport::degCovariates()` to explore potential correlations between variables provided in the metadata and all PCs that account for at least 5% of the variability in the data. If applicable, significant correlations (FDR < 0.1) are circled. **This diagnostic plot helps us determine which variables we may need to add to our DE model.**


```{r covariates, fig.height = 6, fig.width = 10}
degCovariates(
  norm_matrix,
  metrics,
)
```

# Data modeling


```{r init_DESEQ}
formula <- as.formula(paste0("~ ", " + ", column))
## Check if sample name matches
stopifnot(all(names(counts) == rownames(coldata)))

dds_to_use <- DESeqDataSetFromMatrix(counts, coldata, design = formula)

vsd_before <- vst(dds_to_use)
norm_matrix = assay(vsd_before)
new_cdata <- coldata
```

For this study, this formula is  recommended: `r as.character(formula)`

```{r, eval=F, echo=FALSE}
#### IF YOU ARE RUNNING RUV OR COMBATSEQ RUN THE CHUNKS BELOW OTHERWISE SKIP TO Differential Expression SECTION or remove this section
```

## Remove unwanted variation

Removing unwanted variation from RNA-seq analysis is essential to ensure that the results reflect biological rather than technical differences. Methods like ComBat, RUVseq, or surrogate variable analysis (SVA) can be applied to adjust for batch effects, library preparation discrepancies, or other confounders. These techniques model and subtract the unwanted variation, enhancing the ability to detect true biological signals in the data. Proper normalization and careful experimental design are also crucial steps to mitigate such unwanted variation.

### Assessing unknown factors

```{r, results='asis'}
if (run_ruv){
  cat("When performing differential expression analysis, it is important to ensure that any detected differences are truly a result of the experimental comparison being made and not any additional variability in the data.")
}else{
  cat("There is no need to assess unknown factor for this study.")
}
```

```{r do_RUV, eval=run_ruv, echo=run_ruv}
# TOFIX Add to template: check correlation of dummy variables produced by ruvseq with existing covariates in metadata
# NOTE ruvseq (used when you don’t know where the unwanted variation is coming from. Package utilizes dummy variable(s), 1-5 used, start with 1, look at PCA, decide if you want more separation) Add any known-created RUV variables to DESeq2 formula. Normalized matrix produced – only for visualization, not for input into DESeq2
library(RUVSeq)

# If you want to skip the code, just set up formula to be your model in the next chunk of code
design <- coldata[[column]]
diffs <- makeGroups(design)
dat <- norm_matrix
# by default is running one variable, 
# change K parameter to other number to find more unknown covariates
ruvset <- RUVs(dat, cIdx=rownames(dat), k=1, diffs, isLog = T, round = F)
vars <- ruvset$W

new_cdata <- cbind(coldata, vars)

formula <- as.formula(paste0("~ ", 
                          paste0(
                            colnames(new_cdata)[grepl("W", colnames(new_cdata))], 
                            collapse = " + "
                          ), " + ", column)
)
norm_matrix=ruvset$normalizedCounts # NOTE use this for visualization
pca2 <- degPCA(norm_matrix, new_cdata, 
       condition = column) + ggtitle('After RUV')
pca2 + scale_color_cb_friendly()

```

```{r after_RUV, eval=run_ruv}
dds_to_use <- DESeqDataSetFromMatrix(counts, new_cdata, design = formula)
vsd_to_use<- vst(dds_to_use, blind=FALSE)
```

### Remove Batch Effects

```{r combat-text , eval=run_combatseq, results='asis', echo=run_combatseq}
# NOTE Combatseq (part of the SVA package) - corrected count, removing the effects while retaining the structure of the data. Used in a scenario where you know what covariate/batch is. Do not add know-removed known covariates to DESeq2 formula. Also, don’t attempt to remove biological effect (e.g. donor), this is not conceptually valid; best for technical variation.
library(sva)

cat("Here we apply Combat-seq (https://github.com/zhangyuqing/ComBat-seq) to try to remove batch effects so we can better tease out the effects of interest. 
Combat-seq uses a negative binomial regression to model batch effects, providing adjusted data by mapping the original data to an expected distribution if there were no batch effects. The adjusted data preserves the integer nature of counts, so that it is compatible with the assumptions of state-of-the-art differential expression software (e.g. edgeR, DESeq2, which specifically request untransformed count data).")

```

```{r, eval=!run_combatseq, results='asis', echo=run_combatseq}
cat("There is no need to remove known factors like batch effect in this study.")
```

```{r set_variable_combatseq, eval=run_combatseq, echo=run_combatseq}
# NOTE work on this code if you need to run combatseq

# Set your batch effect variable here this is the variable that combatseq will try to remove

## Column name of your batch variable
to_remove = "batch"

## Column name of of your variable(s) of interest

to_keep = "sample_type"

coldata[[to_remove]] <- as.factor(coldata[[to_remove]])
coldata[[to_keep]] <- as.factor(coldata[[to_keep]])

batch = coldata[[to_remove]]
treatment = coldata[[to_keep]]

## If you have multiple variables of interest you will need to cbind them into one variable

#treatment1 = metrics[[to_keep]]
#treatment2 = metrics[[to_keep]]
#treatment3 = metrics[[to_keep]]

# imp = cbind(as.numeric(as.character(treatment1)),as.numeric(as.character(treatment2)), as.numeric(as.character(treatment3)))
```

```{r do_combatseq, eval=run_combatseq}
adjusted_counts <- ComBat_seq(as.matrix(counts), batch=batch, group = treatment)

#NOTE For multiple variables of interest

# adjusted_counts <- ComBat_seq(as.matrix(counts2), batch=batch, covar_mod = imp)
```

```{r after_combatseq, eval=run_combatseq}
# NOTE: Make sure the formula doens't contain the covariates used in combatseq above
dds_to_use <- DESeqDataSetFromMatrix(adjusted_counts, coldata, design = formula)
vsd_combat<- vst(dds_to_use, blind=FALSE)

norm_matrix = assay(vsd_combat)

pca_combat <- degPCA(norm_matrix, coldata, 
       condition = column) + ggtitle('After Combatseq')
pca_combat + scale_color_cb_friendly()
```

# Differential Expression

Differential gene expression analysis of count data was performed using the Bioconductor R package, DESeq2, which fits the count data to a negative binomial model. 

Before fitting the model, we often look at a metric called dispersion, which is a measure for variance which also takes into consideration mean expression. A dispersion value is estimated for each individual gene, then 'shrunken' to a more accurate value based on expected variation for a typical gene exhibiting that level of expression. Finally, the shrunken dispersion value is used in the final GLM fit. 

We use the below dispersion plot, which should show an inverse relationship between dispersion and mean expression, to get an idea of whether our data is a good fit for the model. 

```{r DE}
# NOTE Note VST won’t regress out this when normalizing
de <- DESeq(dds_to_use)
DESeq2::plotDispEsts(de)
```

Because it is difficult to accurately detect and quantify the expression of lowly expressed genes, differences in their expression between treatment conditions can be unduly exaggerated after the model is fit. We correct for this so that gene LFC is not dependent overall on basal gene expression level.

In cases there are multiple groups and conditions across groups is recommended to use dummy variables instead of interaction terms: https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#interactions.

The LRT is useful for testing multiple terms at once, for example testing 3 or more levels of a factor at once, or all interactions between two variables. The LRT for count data is conceptually similar to an analysis of variance (ANOVA) calculation in linear regression, except that in the case of the Negative Binomial GLM, we use an analysis of deviance (ANODEV), where the deviance captures the difference in likelihood between a full and a reduced model.

```{r lfc_shrink}
# NOTE As a note: Use `ashr` for comparisons with many groups to be able to pull out all the contrasts; otherwise `apeglm` is fine. It shrinks less.

# NOTE We recommend LRT for time series

# resultsNames(de) # check the order is right
names_to_use=lapply(contrasts, function(contrast){coef = paste0(contrast[1], "_", contrast[2], "_vs_", contrast[3])})
names(contrasts)=names_to_use
de_list=lapply(contrasts, function(contrast){
  resLFC = results(de, contrast=contrast)
  coef = paste0(contrast[1], "_", contrast[2], "_vs_", contrast[3])
  resLFCS <- lfcShrink(de, coef=coef, type="apeglm")
  # resLFCS <- lfcShrink(de, contrast=contrast, type="ash")
  
  res <- as.data.frame(resLFCS) %>%
    rownames_to_column('gene_id') %>% left_join(rdata, by = 'gene_id') %>% 
    relocate(gene_name) %>% dplyr::rename(lfc = log2FoldChange) %>%
    mutate(pi = abs(lfc) * -log10(padj)) %>% arrange(-pi)
  
  ## Filter out genes that have no expression or were filtered out by DESEQ2
  res <- res[res$baseMean>0,] %>% drop_na(padj) %>% drop_na(pvalue)
  
  res_sig <- res %>% filter(padj < 0.05) %>% arrange(padj) %>%
    mutate(gene_name = ifelse(is.na(gene_name), gene_id, gene_name))
  results=list(lfc=resLFC, lfcs=resLFCS, all=res, sig=res_sig)
  return(results)
})

# NOTE if you add manually any other comparison to the list with the following variables,
# the code below will make the plots for those as wells:
# de_list=c(de_list, new_comparison=list(lfc=resLFC, lfcs=resLFCS, all=res, sig=res_sig))
```

## MA plot {.tabset}

This plot can help to:
- Identify Differential Expression: Genes that show a significant log-fold change (M value away from 0) indicate changes in expression between conditions.
- Assess Data Quality: The plot can help in identifying biases or systematic errors in the data. Ideally, most points should scatter around the M=0 line, indicating that there is no significant systematic difference between the conditions.
- Visualize data dispersion: The distribution of points along the A-axis gives a sense of the spread of expression levels and any patterns or anomalies in the dataset.

```{r after_lfc_shrink, results='asis', message=F, warning=F}
for (contrast in names(de_list)){
  cat("### ", contrast, "\n\n")
  p1=degMA(as.DEGSet(de_list[[contrast]]$lfc)) + ggtitle('Before LFC Shrinking')
  print(p1)
  p2=degMA(as.DEGSet(de_list[[contrast]]$lfcs), limit = 2) + ggtitle('After LFC Shrinking')
  print(p2)
  cat("\n\n")
}
```

## Volcano plot {.tabset}

This volcano plot shows the genes that are significantly up- and down-regulated as a result of the analysis comparison. The points highlighted in red are genes that have padj < 0.05 and a log2-fold change > 1. Points in blue have a padj < 0.05 and a log2-fold change < 1 and points in green have a padj > 0.05 and a log2-fold change > 2. Grey points are non-significant. The dashed lines correspond to the cutoff values of log2 foldchance and padj that we have chosen.

```{r volcano_plot, fig.height=6, results='asis'}
# degVolcano(res_mod[,c('lfc', 'padj')], plot_text = show) 
for (contrast in names(de_list)){
  cat("### ", contrast, "\n\n")
  res <- de_list[[contrast]][["all"]]
  res_mod <- res %>% mutate(lfc = replace(lfc, lfc < -5, -5)) %>% mutate(lfc = replace(lfc, lfc > 5, 5))
  show <- as.data.frame(res_mod[1:10, c("lfc", "padj", "gene_name")])
  p1=EnhancedVolcano(res_mod,
                  lab= res_mod$gene_name, 
                  pCutoff = 0.05, 
                  selectLab = c(show$gene_name),
                  FCcutoff = 0.5,
                  x = 'lfc',
                  y = 'padj', 
                  title=contrast,
                  col=as.vector(colors[c("dark_grey", "light_blue",
                                         "purple", "purple")]),
                  subtitle = "", drawConnectors = T,  max.overlaps = Inf) 
  print(p1)
  cat("\n\n")
}
```

## Heatmap {.tabset}

```{r heapmap, results='asis'}
### Run pheatmap using the metadata data frame for the annotation
for (contrast in names(de_list)){
  cat("### ", contrast, "\n\n")
  res_sig = de_list[[contrast]][["sig"]]
  ma=norm_matrix[res_sig$gene_id,]
  colma=coldata[,c(column), drop=FALSE]
  ma_colors=lapply(colnames(colma), function(c){
    l.col=colors[1:length(unique(colma[[c]]))]
    names(l.col)=unique(colma[[c]])
    l.col
  })
  names(ma_colors)=colnames(colma)
  p1=pheatmap(ma, 
           color = inferno(10), 
           cluster_rows = T, 
           show_rownames = F,
           annotation = colma, 
           annotation_colors = ma_colors,
           border_color = NA, 
           fontsize = 10, 
           scale = "row", 
           fontsize_row = 10, 
           height = 20)
  print(p1)
  cat("\n\n")
}
```


## Differentially Expressed Genes {.tabset}

```{r sig_genes_table, results='asis'}
dt_list=list()
for (contrast in names(de_list)){
  res_sig=de_list[[contrast]][["sig"]]
  dt_list=c(dt_list, 
            list(h3(contrast)), 
            list(DT::datatable(res_sig)))
}
tagList(dt_list)
```

## Plot top 16 genes {.tabset}

```{r top n DEGs, fig.height = 6, fig.width = 8, results='asis'}
n = 16

for (contrast in names(de_list)){
  cat("### ", contrast, "\n\n")
  res_sig = de_list[[contrast]][["sig"]]
  top_n <- res_sig %>% slice_min(order_by = padj, n = n, with_ties = F) %>% 
    dplyr::select(gene_name, gene_id)
  top_n_exp <- norm_matrix %>% as.data.frame() %>% 
    rownames_to_column('gene_id') %>%
    # dplyr::select(-group, -group_name) %>% 
    pivot_longer(!gene_id, names_to = 'sample', values_to = 'log2_expression') %>%
    right_join(top_n, relationship = "many-to-many") %>%
    left_join(coldata, by = 'sample')
  
  p1=ggplot(top_n_exp, aes_string(x = column, y = 'log2_expression')) +
    geom_boxplot(outlier.shape = NA, linewidth=0.5, color="grey") + 
    geom_point() +
    facet_wrap(~gene_name) + 
    ggtitle(str_interp('Expression of Top ${n} DEGs')) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
  print(p1)
  cat("\n\n")
}
```

# Pathway Enrichment

From the set of differentially expressed genes and using publicly available information about gene sets involved in biological processes and functions, we can calculate which biological processes and functions are significantly perturbed as a result of the treatment. 

```{r}
all_in_life=get_databases()
```

# Pathway Analysis- GSEA

Gene Set Enrichment Analysis (GSEA) is a computational method used to determine whether a predefined set of genes shows statistically significant, concordant differences between two biological states (e.g., disease vs. normal) in RNA-seq data or other types of gene expression data. Advantages of GSEA.

- Biological Insight: Helps in understanding the underlying biological processes and pathways affected, rather than focusing on individual genes.
- Incorporation of Prior Knowledge: Utilizes predefined gene sets, allowing integration of existing biological knowledge.
- Contextual Relevance: Can reveal subtle but coordinated changes in biologically meaningful gene sets that might not be apparent when looking at individual genes.

```{r, warning=F, message=F}
fa_gsea_list=lapply(de_list,function(contrast){
  
  res=contrast[["all"]]
  gsea_input = res %>% filter(!is.na(padj)) %>% dplyr::select(gene_id, lfc)
  #change to the right species
  input_entrezid <- AnnotationDbi::select(org.Hs.eg.db, gsea_input$gene_id, 'ENSEMBL', columns = c('ENTREZID', 'SYMBOL'))
  input_entrezid <- inner_join(gsea_input, input_entrezid, by=c("gene_id"="ENSEMBL")) %>%
    filter(!is.na(ENTREZID)) %>% 
    distinct(ENTREZID, .keep_all=TRUE)
  
  tb = run_fgsea(input_entrezid, all_in_life)
  tb %>%  filter(padj<0.05)
 }) 
```

```{r, results='asis'}
# NOTE DT::datatables doesn't work with tabset and for loops
# You can use the following code to print dynamically or call manually sanitize_datatable()
# multiple times
dt_list=list()
for (contrast in names(de_list)){
  res_sig=fa_gsea_list[[contrast]]
  dt_list=c(dt_list, 
            list(h3(contrast)), 
            list(sanitize_datatable(res_sig)))
}
tagList(dt_list)
```

# Pathway Analysis- Over-representation

Over-Representation Analysis (ORA) is a statistical method used to determine whether a predefined set of genes (e.g., genes belonging to a specific biological pathway or function) is over-represented (or enriched) among a list of differentially expressed genes (DEGs) from RNA-seq data. Adventages of ORA:

- Simplicity: Easy to perform and interpret.
- Biological Insight: Helps to identify pathways and processes that are significantly affected in the condition studied.
- Prior Knowledge Integration: Utilizes existing biological knowledge through predefined gene sets.

```{r, warning=F, message=F}
fa_list=lapply(de_list,function(contrast){
  
  res=contrast[["all"]]
  universe=res %>% 
    filter(!is.na(padj)) %>% pull(gene_id)
  universe_mapping = AnnotationDbi::select(org.Hs.eg.db, universe, 'ENSEMBL', columns=c('ENTREZID', 'SYMBOL'))
  
  ora_input = res %>% filter(!is.na(padj), padj<0.01, abs(lfc)>0.3) %>% pull(gene_id)
  #change to the right species
  input_entrezid <- AnnotationDbi::select(org.Hs.eg.db, ora_input, 'ENSEMBL', columns = c('ENTREZID', 'SYMBOL'))
  all=run_fora(input_entrezid, universe_mapping,all_in_life)
  
  ora_input = res %>% filter(!is.na(padj), padj<0.01, lfc>0.3) %>% pull(gene_id)
  #change to the right species
  input_entrezid <- AnnotationDbi::select(org.Hs.eg.db, ora_input, 'ENSEMBL', columns = c('ENTREZID', 'SYMBOL'))
  up=run_fora(input_entrezid, universe_mapping,all_in_life)

  ora_input = res %>% filter(!is.na(padj), padj<0.01, lfc<0.3) %>% pull(gene_id)
  #change to the right species
  input_entrezid <- AnnotationDbi::select(org.Hs.eg.db, ora_input, 'ENSEMBL', columns = c('ENTREZID', 'SYMBOL'))
  down=run_fora(input_entrezid, universe_mapping,all_in_life)

  list(all=all,up=up,down=down)
})
```

## All significant genes {.tabset}

```{r, results='asis'}
# NOTE DT::datatables doesn't work with tabset and for loops
# You can use the following code to print dynamically or call manually sanitize_datatable()
# multiple times
dt_list=list()
for (contrast in names(de_list)){
  res_sig=fa_list[[contrast]][["all"]]
  dt_list=c(dt_list, 
            list(h3(contrast)), 
            list(sanitize_datatable(res_sig)))
}
tagList(dt_list)
```


## Down-regulated genes {.tabset}

```{r, results='asis'}
dt_list=list()
for (contrast in names(de_list)){
  res_sig=fa_list[[contrast]][["down"]]
  dt_list=c(dt_list, 
            list(h3(contrast)), 
            list(sanitize_datatable(res_sig)))
}
tagList(dt_list)
```


## Up-regulated genes {.tabset}

```{r, results='asis'}
dt_list=list()
for (contrast in names(de_list)){
  res_sig=fa_list[[contrast]][["up"]]
  dt_list=c(dt_list, 
            list(h3(contrast)), 
            list(sanitize_datatable(res_sig)))
}
tagList(dt_list)
```


# Save files

```{r write_files}
if (!is.null(subset_value) & !is.null(subset_value)){
  filenames = str_interp("${subset_value}")
} else {
  filenames = ""
}
for (contrast in names(contrasts)){
  filenames = paste0(filenames, "_", contrast)
  name_expression_fn=file.path(
    basedir,
    str_interp("${filenames}_expression.csv"))
  
  name_deg_fn=file.path(
    basedir,
    str_interp("${filenames}_deg.csv"))
  
  name_pathways_fn=file.path(
    basedir,
    str_interp("${filenames}_pathways.csv"))

  counts_norm=norm_matrix %>% as.data.frame() %>% 
    rownames_to_column("gene_id") %>% 
    mutate(comparison = contrast)
  
  res_for_writing <- de_list[[contrast]][["all"]] %>% 
    mutate(comparison = contrast)
  
  # NOTE choose what pathway to save, all, down or up, or everything, just
  #.     need to add more lines
  pathways_for_writing <- fa_list[[contrast]][["all"]] %>% 
    mutate(comparison = contrast)
  
  write_csv(counts_norm, name_expression_fn)
  write_csv(res_for_writing, name_deg_fn)
  write_csv(pathways_for_writing, name_pathways_fn)
}

```

# R session

List and version of tools used for the DE report generation.

```{r}
sessionInfo()
```
